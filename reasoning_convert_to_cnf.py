# -*- coding: utf-8 -*-
"""Reasoning Convert to CNF

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dfefa6yBCGmxuket2EmNM__m_5Lcks05
"""

import re


# Helper methods
def insert_letter_at_position(string, letter, position):
    return string[:position] + letter + string[position:]


def change_char(s, position, new_char):
    return s[:position] + new_char + s[position + 1:]


def remove_spaces(input_string):
    return ''.join(input_string.split())

def remove_char_at_index(string, index):
    if index < 0:
        return string
    elif index >= len(string):
        return string
    else:
        return string[:index] + string[index + 1:]

def replace_subset(string, subset_to_replace, replacement_subset):
    result = ""

    i = 0
    while i < len(string):
        if string[i:i + len(subset_to_replace)] == subset_to_replace:
            # If they match, append the replacement subset to the result
            result += replacement_subset
            i += len(subset_to_replace)
        else:
            result += string[i]
            i += 1

    return result



# 1.Elmination Implecation
def eliminate_implication(formula):
  i = len(formula)

  while(i>=0):
    i=i-1
    pos=0
    if(formula[i]=='>'):
      j=i-1
      while(j>=0):
        j=j-1
        if(formula[j]!=')'):
          pos=j
          formula=insert_letter_at_position(formula, '~', pos)
          break
        else:
          pos=j-3
          formula=insert_letter_at_position(formula, '~', pos)
          break
  result = formula.replace("->", "∨").replace("->", "∨")
  result = result.replace("->", "∨").replace("->", "∨")
  return result


# 2.Move Negation inward
def move_negation_inward(expression):  #~(~f(x)∨y(x))
   i=0
   for letter in expression:
       i+=1
       if(letter=='~' and i<len(expression) and expression[i]=='('):
        expression=change_char(expression,i-1 , ' ')
        expression=insert_letter_at_position(expression , '~' , i+1)
        j=i+1
        stop=0
        while(j<len(expression) and stop!=1):
            if expression[j]=='^' :
              expression =change_char(expression,j,'∨')
              expression=insert_letter_at_position(expression,'~' , j+1)
              stop=1
            elif expression[j]=='∨':

             expression=change_char(expression,j,'^')
             expression=insert_letter_at_position(expression,'~' , j+1)
             stop=1
            j+=1
        # i+=1
   return (expression)



# 3.Remove double not
def remove_double_not(formula):
    return formula.replace("~~", "")



# 4.Standardize variable scope.
def standardize_variable_scope(formula):
    # Extract all variables
    variables = set(re.findall(r'\b[a-zA-Z]+\b', formula))

    # Create a mapping from old variables to new variables
    variable_map = {var: f'{var}{i}' for i, var in enumerate(sorted(variables))}

    # Replace variables with new names
    for old_var, new_var in variable_map.items():
        formula = re.sub(r'\b' + re.escape(old_var) + r'\b', new_var, formula)

    return formula





# 5.Move Quantifiers to the left
def move_quantifiers_left(formula):
    quantifiers = ""
    rest = ""
    i=0
    new_formula=""
    while(i<len(formula)):

      if(formula[i]=='∀' or formula[i]=='∃'):
        quantifiers+=formula[i]
        quantifiers+=formula[i+1]
        quantifiers+=formula[i+2]
        i+=2
      else :
         new_formula = new_formula+ formula[i]

      i=i+1

    return quantifiers+new_formula



# 6. Skolemization for existential quantifiers.
def Skolemization(expression):
  i=-1
  for letter in expression:
    i+=1
    chr="f("
    if(letter == "∃"):
      string=""
      string+=expression[i+1]
      string+=expression[i+2]
      chr+=expression[i+1]
      chr+=expression[i+2]
      chr+=')'
      expression=remove_char_at_index(expression  ,i)
      expression=remove_char_at_index(expression  ,i)
      expression=remove_char_at_index(expression , i)
      expression=replace_subset(expression ,string ,chr)


  return expression






# 7. Eliminate universal quantifiers
def eliminate_universal_quantifiers(formula):
    return re.sub(r'∀([a-zA-Z])([0-9])', '', formula)




# 8. Convert to conjunctive normal form




# 9. Turn conjunctions into clauses in a set, and rename variables so that no clause shares the same variable name.
def parse_clauses(formula):
    # Split the formula into individual clauses
    clauses = re.split(r'\s*∧\s*', formula)
    return clauses



# 10.Rename variables in clauses so that each clause has a unique variable name.
def rename_variables(clauses):
    variable_map = {}
    new_clauses = []
    for clause in clauses:
        new_clause = ""
        variables = set(re.findall(r'\b[a-zA-Z]+\b', clause))
        for var in variables:
            if var not in variable_map:
                variable_map[var] = f'{var}_1'
            new_clause = re.sub(r'\b' + re.escape(var) + r'\b', variable_map[var], clause)
        new_clauses.append(new_clause)
    return new_clauses


def determine(goal , expression):
   tot=0
   cnf_expressions = [to_cnf(expr) for expr in expressions]
   goal='~'+goal
   i=0
   j=1
   while(i<len(cnf_expressions)):
    cnt=0
    while(j<len(cnf_expressions)):
      new_cnf_expressions=insert_letter_at_position(cnf_expressions,'~',0)
      if(cnf_expressions[i]==new_cnf_expressions or cnf_expressions[i]==goal):
        cnt+=1
      j+=1
    if(cnt==len(cnf_expressions)) :
      tot+=1
    i+=1
    if(tot==len(cnf_expressions)-1):
      print("Yes")
    else :
      print("NO")







def convert_to_CNF(expression):
  print("0. The original expression is: ", expression)
  expression=eliminate_implication(remove_spaces(expression))
  print("1. After applying the elimination implication: ", expression)
  expression=move_negation_inward(expression)
  print("2. After applying Move negation inward: ", expression)
  expression=remove_double_not(expression)
  print("3. After Removing double not: ", expression)
  expression=standardize_variable_scope(expression)
  print("4. After standardize variable scope: ", expression)
  expression=move_quantifiers_left(expression)
  print("5. After Moving quantifiers to the left: ", expression)
  expression=Skolemization(expression)
  print("6. After Skolemization: ", expression)
  expression=eliminate_universal_quantifiers(expression)
  print("7. After eliminating universal quantifiers: ", expression)
  expression=parse_clauses(expression)
  print("9. After Parsing clauses: ", expression)
  expression=rename_variables(expression)
  print("10. After renaming variables: ", expression)
  return expression




expression=" ~( f(x) -> Q(y) ^ ∀x∃z ~(g(x) -> p(z))  )"
convert_to_CNF(expression)